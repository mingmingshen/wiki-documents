"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[1472],{10387:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>d,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"NeoEdge NG4500 Series/NG4500-CB01 Development Board/Software Guide/Driver Installation and Updates/Interface&modules configure","title":"Interface","description":"This document mainly introduces the driver control methods for GPIO/I2C/SPI/CAN/USB/UART interfaces.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/1-NeoEdge NG4500 Series/2-NG4500-CB01 Development Board/2-Software Guide/1-Driver Installation and Updates/0-Interface&modules configure.md","sourceDirName":"1-NeoEdge NG4500 Series/2-NG4500-CB01 Development Board/2-Software Guide/1-Driver Installation and Updates","slug":"/NeoEdge NG4500 Series/NG4500-CB01 Development Board/Software Guide/Driver Installation and Updates/Interface&modules configure","permalink":"/wiki-documents/docs/NeoEdge NG4500 Series/NG4500-CB01 Development Board/Software Guide/Driver Installation and Updates/Interface&modules configure","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":0,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Development Environment Setup","permalink":"/wiki-documents/docs/NeoEdge NG4500 Series/NG4500-CB01 Development Board/Software Guide/Development Environment Setup"},"next":{"title":"WIFI","permalink":"/wiki-documents/docs/NeoEdge NG4500 Series/NG4500-CB01 Development Board/Software Guide/Driver Installation and Updates/wifi"}}');var i=r(74848),s=r(28453);const d={},l="Interface",c={},h=[{value:"GPIO",id:"gpio",level:2},{value:"UART",id:"uart",level:2},{value:"SPI",id:"spi",level:2},{value:"CAN",id:"can",level:2},{value:"RTC",id:"rtc",level:2},{value:"Camera",id:"camera",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"interface",children:"Interface"})}),"\n",(0,i.jsx)(n.p,{children:"This document mainly introduces the driver control methods for GPIO/I2C/SPI/CAN/USB/UART interfaces."}),"\n",(0,i.jsx)(n.h2,{id:"gpio",children:"GPIO"}),"\n",(0,i.jsxs)(n.p,{children:["GPIO resource information:",(0,i.jsx)(n.a,{href:"https://developer.nvidia.com/downloads/jetson-orin-nx-and-orin-nano-series-pinmux-config-template",children:"Jetson Orin NX Series and Jetson Orin Nano Series Pinmux"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Io extension panel interface hardware information"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pin #"}),(0,i.jsx)(n.th,{children:"Signal Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Pin Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"218"}),(0,i.jsx)(n.td,{children:"GPIO12"}),(0,i.jsx)(n.td,{children:"GPIO=Low/high when IN1=high\uff08Open\uff09/low(Short)"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"IN1_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"216"}),(0,i.jsx)(n.td,{children:"GPIO11"}),(0,i.jsx)(n.td,{children:"IN2: GPIO=Low/high when IN1=high\uff08Open\uff09/low(Short)"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"IN2_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"206"}),(0,i.jsx)(n.td,{children:"GPIO07"}),(0,i.jsx)(n.td,{children:"IN3: GPIO=Low/high when IN1=high\uff08Open\uff09/low(Short)"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"IN3_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"228"}),(0,i.jsx)(n.td,{children:"GPIO13"}),(0,i.jsx)(n.td,{children:"IN4: GPIO=Low/high when IN1=high\uff08Open\uff09/low(Short)"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"IN4_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"199"}),(0,i.jsx)(n.td,{children:"I2S0_SCLK_1V8"}),(0,i.jsx)(n.td,{children:"OUT1: GPIO=Low for short, high for open"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"OUT1_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"197"}),(0,i.jsx)(n.td,{children:"I2S0_LRCK_1V8"}),(0,i.jsx)(n.td,{children:"OUT2: GPIO=Low for short, high for open"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"OUT2_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"195"}),(0,i.jsx)(n.td,{children:"I2S0_SDIN_1V8"}),(0,i.jsx)(n.td,{children:"OUT3: GPIO=Low for shor, high for open."}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"OUT3_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"193"}),(0,i.jsx)(n.td,{children:"I2S0_SDOUT_1V8"}),(0,i.jsx)(n.td,{children:"OUT4: GPIO=Low for short, high for open."}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"dry contact"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"OUT4_COM: COM pin"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Find the corresponding line using the gpioinfo command"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:r(37987).A+"",width:"865",height:"202"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Control GPIO using gpioset"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"# To set GPIO12 to HIGH\r\nsudo gpioset --mode=wait gpiochip0 144=1\r\n# To set GPIO12 to LOW\r\nsudo gpioset --mode=wait gpiochip0 144=0 \n"})}),"\n",(0,i.jsx)(n.h2,{id:"uart",children:"UART"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Usage on Orin nano/NX"}),(0,i.jsx)(n.th,{children:"UART Instance"}),(0,i.jsx)(n.th,{children:"Base Address"}),(0,i.jsx)(n.th,{children:"Ball Name"}),(0,i.jsx)(n.th,{children:"Bus Name"}),(0,i.jsx)(n.th,{children:"DTS status"}),(0,i.jsx)(n.th,{children:"DTS alias"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Debug"}),(0,i.jsx)(n.td,{children:"UARTC"}),(0,i.jsx)(n.td,{children:"0x0c280000"}),(0,i.jsx)(n.td,{children:"UART2"}),(0,i.jsx)(n.td,{children:"ttyTCU0"}),(0,i.jsx)(n.td,{children:"OK"}),(0,i.jsx)(n.td,{children:"serial0"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RS485"}),(0,i.jsx)(n.td,{children:"UARTA"}),(0,i.jsx)(n.td,{children:"0x03100000"}),(0,i.jsx)(n.td,{children:"UART1"}),(0,i.jsx)(n.td,{children:"ttyTHS1"}),(0,i.jsx)(n.td,{children:"OK"}),(0,i.jsx)(n.td,{children:"serial1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RS232"}),(0,i.jsx)(n.td,{children:"UARTB"}),(0,i.jsx)(n.td,{children:"0x03110000"}),(0,i.jsx)(n.td,{children:"UART0"}),(0,i.jsx)(n.td,{children:"ttyTHS3"}),(0,i.jsx)(n.td,{children:"OK"}),(0,i.jsx)(n.td,{children:"serial3"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Debug"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Hardware connection: Connect Debug cable to PC"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Open serial tool with configuration: Baud rate: 115200, Data bits: 8, Stop bits: 1, Parity: None, Flow control: None"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"RS232"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hardware interface information"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pin"}),(0,i.jsx)(n.th,{children:"Signal Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Pin Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"99"}),(0,i.jsx)(n.td,{children:"UART0_TXD"}),(0,i.jsx)(n.td,{children:"Use for uart Ransmit (with 3.3 level shifter)"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 1.8V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"101"}),(0,i.jsx)(n.td,{children:"UART0_RXD"}),(0,i.jsx)(n.td,{children:"Use for uart\xa0 Receive (with 3.3 level shifter)"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 1.8V"})]})]})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Hardware connection as shown below:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use connector 1 to connect to PC"}),"\n",(0,i.jsxs)(n.li,{children:["Use connector 2 to connect to Jetson's RS232\xa0",(0,i.jsx)(n.code,{children:"TX\\RX"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:r(7038).A+"",width:"1011",height:"687"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"RS485"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hardware interface information"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pin"}),(0,i.jsx)(n.th,{children:"Signal Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Pin Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"203"}),(0,i.jsx)(n.td,{children:"UART1_TXD"}),(0,i.jsx)(n.td,{children:"Use for RS_485"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"CMOS\xa0\xa0\xa0 1.8V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"205"}),(0,i.jsx)(n.td,{children:"UART1_RXD"}),(0,i.jsx)(n.td,{children:"Use for RS_485"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"CMOS\xa0\xa0\xa0 1.8V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"207"}),(0,i.jsx)(n.td,{children:"UART1_RTS*"}),(0,i.jsx)(n.td,{children:"RS_485 enable pin"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"CMOS\xa0\xa0\xa0 1.8V"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Install dependency libraries"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo apt-get update\r\nsudo apt-get install gpiod libgpiod-dev\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compile"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"gcc -o rs485_test rs485_test.c -lgpiod\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Run"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo ./rs485_test [TTY_DIR] [DE_CHIP] [DE_LINE]\r\n# Example\r\nsudo ./rs485_test /dev/ttyTHS1 /dev/gpiochip0 112\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Testing\r\nStart the program, enter\xa0",(0,i.jsx)(n.code,{children:"send"}),"\xa0in the terminal to switch to send mode, then enter the data to be sent and press Enter. The program will send the data to the serial port. Enter\xa0",(0,i.jsx)(n.code,{children:"recv"}),"\xa0to switch to receive mode, where the program will print received data. Enter\xa0",(0,i.jsx)(n.code,{children:"quit"}),"\xa0and press Enter to exit."]}),"\n",(0,i.jsx)(n.li,{children:"Code"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/stat.h>\r\n#include <errno.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <termios.h>\r\n#include <gpiod.h>\r\n#include <linux/serial.h>\r\n\r\n#define BUFFER_SIZE 256\r\n#define RS485_CONSUMER "RS485_program"\r\n\r\nstruct gpiod_chip *chip;\r\nstruct gpiod_line *rts_line;\r\n\r\nvoid setup_gpio(char *gpio_chip, int gpio_line)\r\n{\r\n    int ret;\r\n\r\n    chip = gpiod_chip_open(gpio_chip);\r\n    if (!chip) {\r\n        fprintf(stderr, "gpiod_chip_open");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    rts_line = gpiod_chip_get_line(chip, gpio_line);\r\n    if (!rts_line) {\r\n        fprintf(stderr, "Failed to get GPIO line %d\\n", gpio_line);\r\n        gpiod_chip_close(chip);\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    ret = gpiod_line_request_output(rts_line, RS485_CONSUMER, 0);\r\n    if (ret < 0) {\r\n        fprintf(stderr, "Failed to request GPIO line as output: %s\\n", strerror(-ret));\r\n        gpiod_chip_close(chip);\r\n        exit(EXIT_FAILURE);\r\n    }\r\n}\r\n\r\nvoid set_rts_high() {\r\n    gpiod_line_set_value(rts_line, 1);\r\n    int value = gpiod_line_get_value(rts_line);\r\n    printf("RTS set to HIGH, actual value: %d\\n", value);\r\n}\r\n\r\nvoid set_rts_low() {\r\n    gpiod_line_set_value(rts_line, 0);\r\n    int value = gpiod_line_get_value(rts_line);\r\n    printf("RTS set to LOW, actual value: %d\\n", value);\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    int tty_fd;\r\n    char *tty_name;\r\n    struct termios tty;\r\n    char buffer[BUFFER_SIZE];\r\n    ssize_t n;\r\n    int ready;\r\n    fd_set readfds;\r\n    int rts_line_num;\r\n    char *gpio_chip;\r\n    int mode = 0;\r\n\r\n    if (argc < 4) {\r\n        printf("Usage: %s /dev/ttyTHS1 GPIO_CHIP(/dev/gpiochip*) RTS_LINE\\n", argv[0]);\r\n        return 1;\r\n    }\r\n\r\n    tty_name = argv[1];\r\n    gpio_chip = argv[2];\r\n    rts_line_num = atoi(argv[3]);\r\n\r\n    setup_gpio(gpio_chip, rts_line_num);\r\n\r\n    tty_fd = open(tty_name, O_RDWR | O_NOCTTY | O_NDELAY);\r\n    if (tty_fd < 0) {\r\n        perror("Unable to open serial port");\r\n        return 1;\r\n    }\r\n\r\n    tcgetattr(tty_fd, &tty);\r\n    cfmakeraw(&tty);\r\n    cfsetispeed(&tty, B9600);\r\n    cfsetospeed(&tty, B9600);\r\n    tcsetattr(tty_fd, TCSANOW, &tty);\r\n\r\n    printf("Serial port %s opened successfully, fd: %d\\n", tty_name, tty_fd);\r\n\r\n    while (1) {\r\n        FD_ZERO(&readfds);\r\n        FD_SET(tty_fd, &readfds);\r\n        FD_SET(STDIN_FILENO, &readfds);\r\n\r\n        ready = select(tty_fd + 1, &readfds, NULL, NULL, NULL);\r\n        if (ready == -1) {\r\n            perror("select");\r\n            break;\r\n        }\r\n\r\n        if (FD_ISSET(tty_fd, &readfds)) {\r\n            set_rts_low();\r\n            n = read(tty_fd, buffer, BUFFER_SIZE - 1);\r\n            if (n > 0) {\r\n                buffer[n] = \'\\0\';\r\n                printf("Received: %s\\n", buffer);\r\n            }\r\n        }\r\n\r\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\r\n            if (fgets(buffer, BUFFER_SIZE, stdin) != NULL) {\r\n                buffer[strcspn(buffer, "\\n")] = \'\\0\';\r\n\r\n                if (strcmp(buffer, "send") == 0) {\r\n                    mode = 1;\r\n                    printf("Switched to SEND mode\\n");\r\n                    continue;\r\n                } else if (strcmp(buffer, "recv") == 0) {\r\n                    mode = 0;\r\n                    printf("Switched to RECEIVE mode\\n");\r\n                    continue;\r\n                } else if (strcmp(buffer, "quit") == 0) {\r\n                    break;\r\n                }\r\n\r\n                if (mode == 1) {\r\n                    set_rts_high();\r\n                    usleep(10000);\r\n                    write(tty_fd, buffer, strlen(buffer));\r\n                    tcdrain(tty_fd);\r\n                    set_rts_low();\r\n                } else {\r\n                    printf("Invalid command in RECEIVE mode\\n");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    close(tty_fd);\r\n    gpiod_line_release(rts_line);\r\n    gpiod_chip_close(chip);\r\n\r\n    return 0;\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"spi",children:"SPI"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SPI hardware interface information"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pin"}),(0,i.jsx)(n.th,{children:"Signal Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Pin Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"106"}),(0,i.jsx)(n.td,{children:"SPI1_SCK"}),(0,i.jsx)(n.td,{children:"SPI 1 Clock"}),(0,i.jsx)(n.td,{children:"Bidir"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"108"}),(0,i.jsx)(n.td,{children:"SPI1_MISO"}),(0,i.jsx)(n.td,{children:"SPI 1 Master In / Slave Out"}),(0,i.jsx)(n.td,{children:"Bidir"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"104"}),(0,i.jsx)(n.td,{children:"SPI1_MOSI"}),(0,i.jsx)(n.td,{children:"SPI 1 Master Out / Slave In"}),(0,i.jsx)(n.td,{children:"Bidir"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"110"}),(0,i.jsx)(n.td,{children:"SPI1_CS0*"}),(0,i.jsx)(n.td,{children:"SPI 1 Chip Select 0"}),(0,i.jsx)(n.td,{children:"Bidir"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"112"}),(0,i.jsx)(n.td,{children:"SPI1_CS1*"}),(0,i.jsx)(n.td,{children:"SPI 1 Chip Select 1"}),(0,i.jsx)(n.td,{children:"Bidir"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Hardware connection: Short-circuit\xa0",(0,i.jsx)(n.code,{children:"MOSI"}),"\xa0and\xa0",(0,i.jsx)(n.code,{children:"MISO"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Testing method:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'# Get spi source code\r\ngit clone https://github.com/rm-hull/spidev-test\r\ncd spidev-test/\r\ngcc spidev_test.c -o spidev_test\r\n\r\n#  Test\r\n./spidev_test -v -D /dev/spidev0.0 -p "Test"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"can",children:"CAN"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hardware interface information"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pin"}),(0,i.jsx)(n.th,{children:"Signal Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Pin Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"145"}),(0,i.jsx)(n.td,{children:"CAN_TX"}),(0,i.jsx)(n.td,{children:"FD CAN Transmit"}),(0,i.jsx)(n.td,{children:"Output"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"143"}),(0,i.jsx)(n.td,{children:"CAN_RX"}),(0,i.jsx)(n.td,{children:"FD CAN Receive"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"CMOS \u2013 3.3V"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Hardware connection: Connect D+ and D- between two devices"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Install\xa0",(0,i.jsx)(n.code,{children:"can-utils"}),"\xa0tools"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo apt update\r\nsudo apt-get install can-utils\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Testing method"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"# Check can0 status and configuration\r\nip link show can0\r\n\r\n# Configure can interface with bitrate 100kbps\r\nsudo ip link set can0 up type can bitrate 100000\r\n\r\n# On one device, listen:\r\ncandump can0\r\n\r\n# On another device, send message through can0 interface:\r\ncansend can0 123#11.22.33.44\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rtc",children:"RTC"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modify RTC time"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'sudo hwclock --set --date="2000-01-01 12:00:00"\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check RTC time"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo hwclock -r\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Synchronize time"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"# System time \u2192 RTC\r\nsudo hwclock --systohc\r\n\r\n# RTC \u2192 System time\r\nsudo hwclock --hctosys\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check system time"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"date\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Network time synchronization"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"# If unable to set RTC, check if NTP service is running\r\n# Disable NTP service\r\nsudo systemctl stop systemd-timesyncd.service\r\nsudo timedatectl set-ntp false\n"})}),"\n",(0,i.jsx)(n.h2,{id:"camera",children:"Camera"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Methods for starting and configuring the camera module, using\xa0",(0,i.jsx)(n.code,{children:"imx219"}),"\xa0as an example. The hardware connection is as follows:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:r(84721).A+"",width:"1197",height:"636"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Start the camera using the config-by-hardware.py tool. The configuration will take effect after a reboot."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"# List the currently supported hardware modules\r\nsudo python /opt/nvidia/jetson-io/config-by-hardware.py -l\r\n# Output example:\r\nHeader 1 [default]: Jetson 40pin Header\r\n  Available hardware modules:\r\n  1. Adafruit SPH0645LM4H\r\n  2. Adafruit UDA1334A\r\n  3. FE-PI Audio V1 and Z V2\r\n  4. ReSpeaker 4 Mic Array\r\n  5. ReSpeaker 4 Mic Linear Array\r\nHeader 2: Jetson 24pin CSI Connector\r\n  Available hardware modules:\r\n  1. Camera IMX219 Dual\r\n  2. Camera IMX219 Dual CamThink\r\n  3. Camera IMX219-A\r\n  4. Camera IMX219-A and IMX477-C\r\n  5. Camera IMX219-C\r\n  6. Camera IMX477 Dual\r\n  7. Camera IMX477 Dual 4 lane\r\n  8. Camera IMX477-A\r\n  9. Camera IMX477-A and IMX219-C\r\n  10. Camera IMX477-C\r\nHeader 3: Jetson M.2 Key E Slot\r\n  No hardware configurations found!\r\n\r\n# Select and configure the IMX219 Dual CamThink camera module.\r\n# -n selects the Header number, and Camera IMX219 Dual CamThink is the overlay-name of the dtbo.\r\nsudo python /opt/nvidia/jetson-io/config-by-hardware.py -n 2='Camera IMX219 Dual CamThink'\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Connect a mouse and keyboard, open a terminal, and run the following commands:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo apt update\r\nsudo apt install -y nvidia-l4t-gstreamer nvidia-l4t-jetson-multimedia-api\r\n\r\n# Activate the camera\r\nnvgstcapture-1.0    \n"})})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},37987:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/NG45XX_GPIO-4ddad215d15f82c459cb89ec368f82cf.png"},7038:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/NG45XX_RS232-3e189e55f62006166bbb808b785fcc03.png"},84721:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/NG45XX_IMX219-028db30ad99023127ece3d626bb10ebc.png"},28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>l});var t=r(96540);const i={},s=t.createContext(i);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);